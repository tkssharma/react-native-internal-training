{"ast":null,"code":"var _jsxFileName = \"/Users/srijan/react-native-internal-training/rn-native-app/node_modules/@react-navigation/native/dist/createAppContainer.js\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React from 'react';\nimport Linking from \"react-native-web/dist/exports/Linking\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport BackHandler from \"react-native-web/dist/exports/BackHandler\";\nimport { NavigationActions, pathUtils, getNavigation, NavigationProvider } from '@react-navigation/core';\nimport invariant from \"./utils/invariant\";\nimport docsUrl from \"./utils/docsUrl\";\nvar {\n  urlToPathAndParams\n} = pathUtils;\n\nfunction isStateful(props) {\n  return !props.navigation;\n}\n\nfunction validateProps(props) {\n  if (props.persistenceKey) {\n    console.warn('You passed persistenceKey prop to a navigator. ' + 'The persistenceKey prop was replaced by a more flexible persistence mechanism, ' + 'please see the navigation state persistence docs for more information. ' + 'Passing the persistenceKey prop is a no-op.');\n  }\n\n  if (isStateful(props)) {\n    return;\n  }\n\n  var {\n    navigation,\n    screenProps,\n    persistNavigationState,\n    loadNavigationState\n  } = props,\n      containerProps = _objectWithoutProperties(props, [\"navigation\", \"screenProps\", \"persistNavigationState\", \"loadNavigationState\"]);\n\n  var keys = Object.keys(containerProps);\n\n  if (keys.length !== 0) {\n    throw new Error('This navigator has both navigation and container props, so it is ' + \"unclear if it should own its own state. Remove props: \\\"\".concat(keys.join(', '), \"\\\" \") + 'if the navigator should get its state from the navigation prop. If the ' + 'navigator should maintain its own state, do not pass a navigation prop.');\n  }\n\n  invariant(persistNavigationState === undefined && loadNavigationState === undefined || typeof persistNavigationState === 'function' && typeof loadNavigationState === 'function', 'both persistNavigationState and loadNavigationState must either be undefined, or be functions');\n}\n\nvar _statefulContainerCount = 0;\nexport function _TESTING_ONLY_reset_container_count() {\n  _statefulContainerCount = 0;\n}\nvar _reactNavigationIsHydratingState = false;\nexport default function createNavigationContainer(Component) {\n  class NavigationContainer extends React.Component {\n    static getDerivedStateFromProps(nextProps) {\n      validateProps(nextProps);\n      return null;\n    }\n\n    constructor(props) {\n      var _this;\n\n      super(props);\n      _this = this;\n      this.subs = null;\n      this._actionEventSubscribers = new Set();\n\n      this._handleOpenURL = (_ref) => {\n        var {\n          url\n        } = _ref;\n        var {\n          enableURLHandling,\n          uriPrefix\n        } = this.props;\n\n        if (enableURLHandling === false) {\n          return;\n        }\n\n        var parsedUrl = urlToPathAndParams(url, uriPrefix);\n\n        if (parsedUrl) {\n          var {\n            path,\n            params\n          } = parsedUrl;\n          var action = Component.router.getActionForPathAndParams(path, params);\n\n          if (action) {\n            this.dispatch(action);\n          }\n        }\n      };\n\n      this._persistNavigationState = function () {\n        var _ref2 = _asyncToGenerator(function* (nav) {\n          var {\n            persistNavigationState\n          } = _this.props;\n\n          if (persistNavigationState) {\n            try {\n              yield persistNavigationState(nav);\n            } catch (err) {\n              console.warn('Uncaught exception while calling persistNavigationState()! You should handle exceptions thrown from persistNavigationState(), ignoring them may result in undefined behavior.');\n            }\n          }\n        });\n\n        return function (_x) {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n\n      this.dispatch = action => {\n        if (this.props.navigation) {\n          return this.props.navigation.dispatch(action);\n        }\n\n        this._navState = this._navState || this.state.nav;\n        var lastNavState = this._navState;\n        invariant(lastNavState, 'should be set in constructor if stateful');\n        var reducedState = Component.router.getStateForAction(action, lastNavState);\n        var navState = reducedState === null ? lastNavState : reducedState;\n\n        var dispatchActionEvents = () => {\n          this._actionEventSubscribers.forEach(subscriber => subscriber({\n            type: 'action',\n            action,\n            state: navState,\n            lastState: lastNavState\n          }));\n        };\n\n        if (reducedState === null) {\n          dispatchActionEvents();\n          return true;\n        }\n\n        if (navState !== lastNavState) {\n          this._navState = navState;\n          this.setState({\n            nav: navState\n          }, () => {\n            this._onNavigationStateChange(lastNavState, navState, action);\n\n            dispatchActionEvents();\n\n            this._persistNavigationState(navState);\n          });\n          return true;\n        }\n\n        dispatchActionEvents();\n        return false;\n      };\n\n      this._getScreenProps = () => this.props.screenProps;\n\n      validateProps(props);\n      this._initialAction = NavigationActions.init();\n\n      if (this._isStateful() && BackHandler && typeof BackHandler.addEventListener === 'function') {\n        this.subs = BackHandler.addEventListener('hardwareBackPress', () => {\n          if (!this._isMounted) {\n            this.subs && this.subs.remove();\n          } else {\n            return this.dispatch(NavigationActions.back());\n          }\n        });\n      }\n\n      this.state = {\n        nav: this._isStateful() && !props.loadNavigationState ? Component.router.getStateForAction(this._initialAction) : null\n      };\n    }\n\n    _renderLoading() {\n      return this.props.renderLoadingExperimental ? this.props.renderLoadingExperimental() : null;\n    }\n\n    _isStateful() {\n      return isStateful(this.props);\n    }\n\n    _validateProps(props) {\n      if (this._isStateful()) {\n        return;\n      }\n\n      var {\n        navigation,\n        screenProps\n      } = props,\n          containerProps = _objectWithoutProperties(props, [\"navigation\", \"screenProps\"]);\n\n      var keys = Object.keys(containerProps);\n\n      if (keys.length !== 0) {\n        throw new Error('This navigator has both navigation and container props, so it is ' + \"unclear if it should own its own state. Remove props: \\\"\".concat(keys.join(', '), \"\\\" \") + 'if the navigator should get its state from the navigation prop. If the ' + 'navigator should maintain its own state, do not pass a navigation prop.');\n      }\n    }\n\n    _onNavigationStateChange(prevNav, nav, action) {\n      if (typeof this.props.onNavigationStateChange === 'undefined' && this._isStateful() && !!process.env.REACT_NAV_LOGGING) {\n        if (console.group) {\n          console.group('Navigation Dispatch: ');\n          console.log('Action: ', action);\n          console.log('New State: ', nav);\n          console.log('Last State: ', prevNav);\n          console.groupEnd();\n        } else {\n          console.log('Navigation Dispatch: ', {\n            action,\n            newState: nav,\n            lastState: prevNav\n          });\n        }\n\n        return;\n      }\n\n      if (typeof this.props.onNavigationStateChange === 'function') {\n        this.props.onNavigationStateChange(prevNav, nav, action);\n      }\n    }\n\n    componentDidUpdate() {\n      if (this._navState === this.state.nav) {\n        this._navState = null;\n      }\n    }\n\n    componentDidMount() {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* () {\n        _this2._isMounted = true;\n\n        if (!_this2._isStateful()) {\n          return;\n        }\n\n        if (__DEV__ && !_this2.props.detached) {\n          if (_statefulContainerCount > 0) {\n            if (Platform.OS === 'ios') {\n              console.warn(\"You should only render one navigator explicitly in your app, and other navigators should be rendered by including them in that navigator. Full details at: \".concat(docsUrl('common-mistakes.html#explicitly-rendering-more-than-one-navigator')));\n            }\n          }\n        }\n\n        _statefulContainerCount++;\n        Linking.addEventListener('url', _this2._handleOpenURL);\n        var parsedUrl = null;\n        var userProvidedStartupState = null;\n\n        if (_this2.props.enableURLHandling !== false) {\n          ({\n            parsedUrl,\n            userProvidedStartupState\n          } = yield _this2.getStartupParams());\n        }\n\n        var action = _this2._initialAction;\n        var startupState = _this2.state.nav;\n\n        if (!startupState && !userProvidedStartupState) {\n          !!process.env.REACT_NAV_LOGGING && console.log('Init new Navigation State');\n          startupState = Component.router.getStateForAction(action);\n        }\n\n        if (userProvidedStartupState) {\n          startupState = userProvidedStartupState;\n          _reactNavigationIsHydratingState = true;\n        }\n\n        if (parsedUrl) {\n          var {\n            path,\n            params\n          } = parsedUrl;\n          var urlAction = Component.router.getActionForPathAndParams(path, params);\n\n          if (urlAction) {\n            !!process.env.REACT_NAV_LOGGING && console.log('Applying Navigation Action for Initial URL:', parsedUrl);\n            action = urlAction;\n            startupState = Component.router.getStateForAction(urlAction, startupState);\n          }\n        }\n\n        var dispatchActions = () => _this2._actionEventSubscribers.forEach(subscriber => subscriber({\n          type: 'action',\n          action,\n          state: _this2.state.nav,\n          lastState: null\n        }));\n\n        if (startupState === _this2.state.nav) {\n          dispatchActions();\n          return;\n        }\n\n        _this2.setState({\n          nav: startupState\n        }, () => {\n          _reactNavigationIsHydratingState = false;\n          dispatchActions();\n        });\n      })();\n    }\n\n    getStartupParams() {\n      var _this3 = this;\n\n      return _asyncToGenerator(function* () {\n        var {\n          uriPrefix,\n          loadNavigationState\n        } = _this3.props;\n        var url, loadedNavState;\n\n        try {\n          [url, loadedNavState] = yield Promise.all([Linking.getInitialURL(), loadNavigationState && loadNavigationState()]);\n        } catch (err) {}\n\n        return {\n          parsedUrl: url && urlToPathAndParams(url, uriPrefix),\n          userProvidedStartupState: loadedNavState\n        };\n      })();\n    }\n\n    componentDidCatch(e) {\n      if (_reactNavigationIsHydratingState) {\n        _reactNavigationIsHydratingState = false;\n        console.warn('Uncaught exception while starting app from persisted navigation state! Trying to render again with a fresh navigation state...');\n        this.dispatch(NavigationActions.init());\n      } else {\n        throw e;\n      }\n    }\n\n    componentWillUnmount() {\n      this._isMounted = false;\n      Linking.removeEventListener('url', this._handleOpenURL);\n      this.subs && this.subs.remove();\n\n      if (this._isStateful()) {\n        _statefulContainerCount--;\n      }\n    }\n\n    render() {\n      var navigation = this.props.navigation;\n\n      if (this._isStateful()) {\n        var navState = this.state.nav;\n\n        if (!navState) {\n          return this._renderLoading();\n        }\n\n        if (!this._navigation || this._navigation.state !== navState) {\n          this._navigation = getNavigation(Component.router, navState, this.dispatch, this._actionEventSubscribers, this._getScreenProps, () => this._navigation);\n        }\n\n        navigation = this._navigation;\n      }\n\n      invariant(navigation, 'failed to get navigation');\n      return React.createElement(NavigationProvider, {\n        value: navigation,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 347\n        }\n      }, React.createElement(Component, _extends({}, this.props, {\n        navigation: navigation,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 348\n        }\n      })));\n    }\n\n  }\n\n  NavigationContainer.router = Component.router;\n  NavigationContainer.navigationOptions = null;\n  return NavigationContainer;\n}","map":{"version":3,"sources":["/Users/srijan/react-native-internal-training/rn-native-app/node_modules/@react-navigation/native/dist/createAppContainer.js"],"names":["React","NavigationActions","pathUtils","getNavigation","NavigationProvider","invariant","docsUrl","urlToPathAndParams","isStateful","props","navigation","validateProps","persistenceKey","console","warn","screenProps","persistNavigationState","loadNavigationState","containerProps","keys","Object","length","Error","join","undefined","_statefulContainerCount","_TESTING_ONLY_reset_container_count","_reactNavigationIsHydratingState","createNavigationContainer","Component","NavigationContainer","getDerivedStateFromProps","nextProps","constructor","subs","_actionEventSubscribers","Set","_handleOpenURL","url","enableURLHandling","uriPrefix","parsedUrl","path","params","action","router","getActionForPathAndParams","dispatch","_persistNavigationState","nav","err","_navState","state","lastNavState","reducedState","getStateForAction","navState","dispatchActionEvents","forEach","subscriber","type","lastState","setState","_onNavigationStateChange","_getScreenProps","_initialAction","init","_isStateful","BackHandler","addEventListener","_isMounted","remove","back","_renderLoading","renderLoadingExperimental","_validateProps","prevNav","onNavigationStateChange","process","env","REACT_NAV_LOGGING","group","log","groupEnd","newState","componentDidUpdate","componentDidMount","__DEV__","detached","Platform","OS","Linking","userProvidedStartupState","getStartupParams","startupState","urlAction","dispatchActions","loadedNavState","Promise","all","getInitialURL","componentDidCatch","e","componentWillUnmount","removeEventListener","render","_navigation","navigationOptions"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { Linking, Platform, BackHandler } from 'react-native';\nimport { NavigationActions, pathUtils, getNavigation, NavigationProvider } from '@react-navigation/core';\nimport invariant from './utils/invariant';\nimport docsUrl from './utils/docsUrl';\n\nconst { urlToPathAndParams } = pathUtils;\n\nfunction isStateful(props) {\n  return !props.navigation;\n}\n\nfunction validateProps(props) {\n  if (props.persistenceKey) {\n    console.warn('You passed persistenceKey prop to a navigator. ' + 'The persistenceKey prop was replaced by a more flexible persistence mechanism, ' + 'please see the navigation state persistence docs for more information. ' + 'Passing the persistenceKey prop is a no-op.');\n  }\n  if (isStateful(props)) {\n    return;\n  }\n  /* eslint-disable no-unused-vars */\n  const {\n    navigation,\n    screenProps,\n    persistNavigationState,\n    loadNavigationState,\n    ...containerProps\n  } = props;\n  /* eslint-enable no-unused-vars */\n\n  const keys = Object.keys(containerProps);\n\n  if (keys.length !== 0) {\n    throw new Error('This navigator has both navigation and container props, so it is ' + `unclear if it should own its own state. Remove props: \"${keys.join(', ')}\" ` + 'if the navigator should get its state from the navigation prop. If the ' + 'navigator should maintain its own state, do not pass a navigation prop.');\n  }\n  invariant(persistNavigationState === undefined && loadNavigationState === undefined || typeof persistNavigationState === 'function' && typeof loadNavigationState === 'function', 'both persistNavigationState and loadNavigationState must either be undefined, or be functions');\n}\n\n// Track the number of stateful container instances. Warn if >0 and not using the\n// detached prop to explicitly acknowledge the behavior. We should deprecated implicit\n// stateful navigation containers in a future release and require a provider style pattern\n// instead in order to eliminate confusion entirely.\nlet _statefulContainerCount = 0;\nexport function _TESTING_ONLY_reset_container_count() {\n  _statefulContainerCount = 0;\n}\n\n// We keep a global flag to catch errors during the state persistence hydrating scenario.\n// The innermost navigator who catches the error will dispatch a new init action.\nlet _reactNavigationIsHydratingState = false;\n// Unfortunate to use global state here, but it seems necessesary for the time\n// being. There seems to be some problems with cascading componentDidCatch\n// handlers. Ideally the inner non-stateful navigator catches the error and\n// re-throws it, to be caught by the top-level stateful navigator.\n\n/**\n * Create an HOC that injects the navigation and manages the navigation state\n * in case it's not passed from above.\n * This allows to use e.g. the StackNavigator and TabNavigator as root-level\n * components.\n */\nexport default function createNavigationContainer(Component) {\n  class NavigationContainer extends React.Component {\n    subs = null;\n\n    static router = Component.router;\n    static navigationOptions = null;\n\n    static getDerivedStateFromProps(nextProps) {\n      validateProps(nextProps);\n      return null;\n    }\n\n    _actionEventSubscribers = new Set();\n\n    constructor(props) {\n      super(props);\n\n      validateProps(props);\n\n      this._initialAction = NavigationActions.init();\n\n      if (this._isStateful() && BackHandler && typeof BackHandler.addEventListener === 'function') {\n        this.subs = BackHandler.addEventListener('hardwareBackPress', () => {\n          if (!this._isMounted) {\n            this.subs && this.subs.remove();\n          } else {\n            // dispatch returns true if the action results in a state change,\n            // and false otherwise. This maps well to what BackHandler expects\n            // from a callback -- true if handled, false if not handled\n            return this.dispatch(NavigationActions.back());\n          }\n        });\n      }\n\n      this.state = {\n        nav: this._isStateful() && !props.loadNavigationState ? Component.router.getStateForAction(this._initialAction) : null\n      };\n    }\n\n    _renderLoading() {\n      return this.props.renderLoadingExperimental ? this.props.renderLoadingExperimental() : null;\n    }\n\n    _isStateful() {\n      return isStateful(this.props);\n    }\n\n    _validateProps(props) {\n      if (this._isStateful()) {\n        return;\n      }\n\n      // eslint-disable-next-line no-unused-vars\n      const { navigation, screenProps, ...containerProps } = props;\n\n      const keys = Object.keys(containerProps);\n\n      if (keys.length !== 0) {\n        throw new Error('This navigator has both navigation and container props, so it is ' + `unclear if it should own its own state. Remove props: \"${keys.join(', ')}\" ` + 'if the navigator should get its state from the navigation prop. If the ' + 'navigator should maintain its own state, do not pass a navigation prop.');\n      }\n    }\n\n    _handleOpenURL = ({ url }) => {\n      const { enableURLHandling, uriPrefix } = this.props;\n      if (enableURLHandling === false) {\n        return;\n      }\n      const parsedUrl = urlToPathAndParams(url, uriPrefix);\n      if (parsedUrl) {\n        const { path, params } = parsedUrl;\n        const action = Component.router.getActionForPathAndParams(path, params);\n        if (action) {\n          this.dispatch(action);\n        }\n      }\n    };\n\n    _onNavigationStateChange(prevNav, nav, action) {\n      if (typeof this.props.onNavigationStateChange === 'undefined' && this._isStateful() && !!process.env.REACT_NAV_LOGGING) {\n        if (console.group) {\n          console.group('Navigation Dispatch: ');\n          console.log('Action: ', action);\n          console.log('New State: ', nav);\n          console.log('Last State: ', prevNav);\n          console.groupEnd();\n        } else {\n          console.log('Navigation Dispatch: ', {\n            action,\n            newState: nav,\n            lastState: prevNav\n          });\n        }\n        return;\n      }\n\n      if (typeof this.props.onNavigationStateChange === 'function') {\n        this.props.onNavigationStateChange(prevNav, nav, action);\n      }\n    }\n\n    componentDidUpdate() {\n      // Clear cached _navState every tick\n      if (this._navState === this.state.nav) {\n        this._navState = null;\n      }\n    }\n\n    async componentDidMount() {\n      this._isMounted = true;\n      if (!this._isStateful()) {\n        return;\n      }\n\n      if (__DEV__ && !this.props.detached) {\n        if (_statefulContainerCount > 0) {\n          // Temporarily only show this on iOS due to this issue:\n          // https://github.com/react-navigation/react-navigation/issues/4196#issuecomment-390827829\n          if (Platform.OS === 'ios') {\n            console.warn(`You should only render one navigator explicitly in your app, and other navigators should be rendered by including them in that navigator. Full details at: ${docsUrl('common-mistakes.html#explicitly-rendering-more-than-one-navigator')}`);\n          }\n        }\n      }\n      _statefulContainerCount++;\n      Linking.addEventListener('url', this._handleOpenURL);\n\n      // Pull out anything that can impact state\n      let parsedUrl = null;\n      let userProvidedStartupState = null;\n      if (this.props.enableURLHandling !== false) {\n        ({\n          parsedUrl,\n          userProvidedStartupState\n        } = await this.getStartupParams());\n      }\n\n      // Initialize state. This must be done *after* any async code\n      // so we don't end up with a different value for this.state.nav\n      // due to changes while async function was resolving\n      let action = this._initialAction;\n      let startupState = this.state.nav;\n      if (!startupState && !userProvidedStartupState) {\n        !!process.env.REACT_NAV_LOGGING && console.log('Init new Navigation State');\n        startupState = Component.router.getStateForAction(action);\n      }\n\n      // Pull user-provided persisted state\n      if (userProvidedStartupState) {\n        startupState = userProvidedStartupState;\n        _reactNavigationIsHydratingState = true;\n      }\n\n      // Pull state out of URL\n      if (parsedUrl) {\n        const { path, params } = parsedUrl;\n        const urlAction = Component.router.getActionForPathAndParams(path, params);\n        if (urlAction) {\n          !!process.env.REACT_NAV_LOGGING && console.log('Applying Navigation Action for Initial URL:', parsedUrl);\n          action = urlAction;\n          startupState = Component.router.getStateForAction(urlAction, startupState);\n        }\n      }\n\n      const dispatchActions = () => this._actionEventSubscribers.forEach(subscriber => subscriber({\n        type: 'action',\n        action,\n        state: this.state.nav,\n        lastState: null\n      }));\n\n      if (startupState === this.state.nav) {\n        dispatchActions();\n        return;\n      }\n\n      // eslint-disable-next-line react/no-did-mount-set-state\n      this.setState({ nav: startupState }, () => {\n        _reactNavigationIsHydratingState = false;\n        dispatchActions();\n      });\n    }\n\n    async getStartupParams() {\n      const { uriPrefix, loadNavigationState } = this.props;\n      let url, loadedNavState;\n      try {\n        [url, loadedNavState] = await Promise.all([Linking.getInitialURL(), loadNavigationState && loadNavigationState()]);\n      } catch (err) {\n        // ignore\n      }\n      return {\n        parsedUrl: url && urlToPathAndParams(url, uriPrefix),\n        userProvidedStartupState: loadedNavState\n      };\n    }\n\n    componentDidCatch(e) {\n      if (_reactNavigationIsHydratingState) {\n        _reactNavigationIsHydratingState = false;\n        console.warn('Uncaught exception while starting app from persisted navigation state! Trying to render again with a fresh navigation state...');\n        this.dispatch(NavigationActions.init());\n      } else {\n        throw e;\n      }\n    }\n\n    _persistNavigationState = async nav => {\n      const { persistNavigationState } = this.props;\n      if (persistNavigationState) {\n        try {\n          await persistNavigationState(nav);\n        } catch (err) {\n          console.warn('Uncaught exception while calling persistNavigationState()! You should handle exceptions thrown from persistNavigationState(), ignoring them may result in undefined behavior.');\n        }\n      }\n    };\n\n    componentWillUnmount() {\n      this._isMounted = false;\n      Linking.removeEventListener('url', this._handleOpenURL);\n      this.subs && this.subs.remove();\n\n      if (this._isStateful()) {\n        _statefulContainerCount--;\n      }\n    }\n\n    // Per-tick temporary storage for state.nav\n\n    dispatch = action => {\n      if (this.props.navigation) {\n        return this.props.navigation.dispatch(action);\n      }\n\n      // navState will have the most up-to-date value, because setState sometimes behaves asyncronously\n      this._navState = this._navState || this.state.nav;\n      const lastNavState = this._navState;\n      invariant(lastNavState, 'should be set in constructor if stateful');\n      const reducedState = Component.router.getStateForAction(action, lastNavState);\n      const navState = reducedState === null ? lastNavState : reducedState;\n\n      const dispatchActionEvents = () => {\n        this._actionEventSubscribers.forEach(subscriber => subscriber({\n          type: 'action',\n          action,\n          state: navState,\n          lastState: lastNavState\n        }));\n      };\n\n      if (reducedState === null) {\n        // The router will return null when action has been handled and the state hasn't changed.\n        // dispatch returns true when something has been handled.\n        dispatchActionEvents();\n        return true;\n      }\n\n      if (navState !== lastNavState) {\n        // Cache updates to state.nav during the tick to ensure that subsequent calls will not discard this change\n        this._navState = navState;\n        this.setState({ nav: navState }, () => {\n          this._onNavigationStateChange(lastNavState, navState, action);\n          dispatchActionEvents();\n          this._persistNavigationState(navState);\n        });\n        return true;\n      }\n\n      dispatchActionEvents();\n      return false;\n    };\n\n    _getScreenProps = () => this.props.screenProps;\n\n    render() {\n      let navigation = this.props.navigation;\n      if (this._isStateful()) {\n        const navState = this.state.nav;\n        if (!navState) {\n          return this._renderLoading();\n        }\n        if (!this._navigation || this._navigation.state !== navState) {\n          this._navigation = getNavigation(Component.router, navState, this.dispatch, this._actionEventSubscribers, this._getScreenProps, () => this._navigation);\n        }\n        navigation = this._navigation;\n      }\n      invariant(navigation, 'failed to get navigation');\n      return <NavigationProvider value={navigation}>\n          <Component {...this.props} navigation={navigation} />\n        </NavigationProvider>;\n    }\n  }\n\n  return NavigationContainer;\n}"]},"metadata":{},"sourceType":"module"}